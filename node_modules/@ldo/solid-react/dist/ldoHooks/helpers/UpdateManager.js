"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateManager = void 0;
const dataset_1 = require("@ldo/dataset");
const jsonld_dataset_proxy_1 = require("@ldo/jsonld-dataset-proxy");
class UpdateManager {
    constructor() {
        this.tripleMatchListenerMap = {};
        this.listenerHashMap = new Map();
    }
    tripleMatchToHash(tripleMatch) {
        return `${(0, jsonld_dataset_proxy_1.nodeToString)(tripleMatch[0])}${(0, jsonld_dataset_proxy_1.nodeToString)(tripleMatch[1])}${(0, jsonld_dataset_proxy_1.nodeToString)(tripleMatch[2])}`;
    }
    registerListener(tripleMatch, callback) {
        const hash = this.tripleMatchToHash(tripleMatch);
        if (!this.tripleMatchListenerMap[hash]) {
            this.tripleMatchListenerMap[hash] = new Set();
        }
        if (!this.listenerHashMap.has(callback)) {
            this.listenerHashMap.set(callback, new Set());
        }
        this.tripleMatchListenerMap[hash].add(callback);
        this.listenerHashMap.get(callback)?.add(hash);
    }
    removeListener(callback) {
        const hashSet = this.listenerHashMap.get(callback);
        if (hashSet) {
            hashSet.forEach((hash) => {
                this.tripleMatchListenerMap[hash]?.delete(callback);
            });
        }
    }
    notifyListenersOfChanges(changes) {
        const listenersToNotify = new Set();
        const allQuads = (0, dataset_1.createDataset)();
        allQuads.addAll(changes.added || []);
        allQuads.addAll(changes.removed || []);
        allQuads.forEach((tempQuad) => {
            const quad = tempQuad;
            const tripleMatches = [
                [null, null, null],
                [quad.subject, null, null],
                [quad.subject, quad.predicate, null],
                [quad.subject, null, quad.object],
                [null, quad.predicate, null],
                [null, quad.predicate, quad.object],
                [null, null, quad.object],
                [quad.subject, quad.predicate, quad.object],
            ];
            tripleMatches.forEach((tripleMatch) => {
                const hash = this.tripleMatchToHash(tripleMatch);
                this.tripleMatchListenerMap[hash]?.forEach((callback) => {
                    listenersToNotify.add(callback);
                });
                delete this.tripleMatchListenerMap[hash];
            });
        });
        listenersToNotify.forEach((listener) => {
            listener();
        });
    }
}
exports.UpdateManager = UpdateManager;
//# sourceMappingURL=UpdateManager.js.map