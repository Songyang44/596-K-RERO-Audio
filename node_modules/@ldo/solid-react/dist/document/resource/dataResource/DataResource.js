"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataResource = void 0;
const ldo_1 = require("@ldo/ldo");
const Resource_1 = require("../Resource");
const DocumentFetchError_1 = require("../../errors/DocumentFetchError");
const DocumentError_1 = require("../../errors/DocumentError");
const data_model_1 = require("@rdfjs/data-model");
const changesToSparqlUpdate_1 = require("../../../util/changesToSparqlUpdate");
class DataResource extends Resource_1.Resource {
    constructor(uri, dependencies) {
        super(uri, dependencies);
        this.dependencies2 = dependencies;
    }
    get dataset() {
        return this.dependencies2.dataset;
    }
    get updateManager() {
        return this.dependencies2.updateManager;
    }
    async create() {
    }
    async fetchDocument() {
        const response = await this.fetch(this.uri, {
            headers: {
                accept: "text/turtle",
            },
        });
        if (response.status !== 200) {
            return new DocumentFetchError_1.DocumentFetchError(this, response.status, `Error fetching resource ${this.uri}`);
        }
        const rawTurtle = await response.text();
        let loadedDataset;
        try {
            loadedDataset = await (0, ldo_1.parseRdf)(rawTurtle, {
                baseIRI: this.uri,
            });
        }
        catch (err) {
            if (typeof err === "object" && err.message) {
                return new DocumentError_1.DocumentError(this, err.message);
            }
            return new DocumentError_1.DocumentError(this, "Server returned poorly formatted Turtle");
        }
        const transactionalDataset = this.dataset.startTransaction();
        const graphNode = (0, data_model_1.namedNode)(this.uri);
        loadedDataset.deleteMatches(undefined, undefined, undefined, graphNode);
        loadedDataset.forEach((quad) => {
            transactionalDataset.add((0, data_model_1.quad)(quad.subject, quad.predicate, quad.object, graphNode));
        });
        const changes = transactionalDataset.getChanges();
        this.updateManager.notifyListenersOfChanges(changes);
        transactionalDataset.commit();
        return undefined;
    }
    async update(changes) {
        this.beginWrite();
        const transactionalDataset = this.dataset.startTransaction();
        changes.added?.forEach((quad) => transactionalDataset.add(quad));
        changes.removed?.forEach((quad) => transactionalDataset.delete(quad));
        transactionalDataset.commit();
        this.updateManager.notifyListenersOfChanges(changes);
        const sparqlUpdate = await (0, changesToSparqlUpdate_1.changesToSparqlUpdate)(changes);
        const response = await this.fetch(this.uri, {
            method: "PATCH",
            body: sparqlUpdate,
            headers: {
                "Content-Type": "application/sparql-update",
            },
        });
        if (response.status < 200 || response.status > 299) {
            transactionalDataset.rollback();
            this.updateManager.notifyListenersOfChanges(changes);
            this.endWrite(new DocumentFetchError_1.DocumentFetchError(this, response.status, `Problem writing to ${this.uri}`));
            return;
        }
        this.endWrite();
    }
}
exports.DataResource = DataResource;
//# sourceMappingURL=DataResource.js.map