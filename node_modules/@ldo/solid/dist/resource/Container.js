"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Container = void 0;
const data_model_1 = require("@rdfjs/data-model");
const ContainerRequester_1 = require("../requester/ContainerRequester");
const ErrorResult_1 = require("../requester/results/error/ErrorResult");
const NoncompliantPodError_1 = require("../requester/results/error/NoncompliantPodError");
const rdfUtils_1 = require("../util/rdfUtils");
const Resource_1 = require("./Resource");
class Container extends Resource_1.Resource {
    constructor(uri, context) {
        super(context);
        this.type = "container";
        this.isError = false;
        this.uri = uri;
        this.requester = new ContainerRequester_1.ContainerRequester(uri, context);
        this.status = { isError: false, type: "unfetched", uri };
    }
    isRootContainer() {
        return this.rootContainer;
    }
    updateWithReadSuccess(result) {
        super.updateWithReadSuccess(result);
        if (result.type === "containerReadSuccess") {
            this.rootContainer = result.isRootContainer;
        }
    }
    async read() {
        const result = (await this.handleRead());
        if (result.isError)
            return result;
        return { ...result, resource: this };
    }
    toReadResult() {
        if (this.isAbsent()) {
            return {
                isError: false,
                type: "absentReadSuccess",
                uri: this.uri,
                recalledFromMemory: true,
                resource: this,
            };
        }
        else {
            return {
                isError: false,
                type: "containerReadSuccess",
                uri: this.uri,
                recalledFromMemory: true,
                isRootContainer: this.isRootContainer(),
                resource: this,
            };
        }
    }
    async readIfUnfetched() {
        return super.readIfUnfetched();
    }
    async checkIfIsRootContainer() {
        const rootContainerResult = await this.requester.isRootContainer();
        this.status = rootContainerResult;
        if (rootContainerResult.isError)
            return rootContainerResult;
        this.rootContainer = rootContainerResult.isRootContainer;
        this.emit("update");
        return { ...rootContainerResult, resource: this };
    }
    async getRootContainer() {
        if (this.rootContainer === undefined) {
            const checkResult = await this.checkIfIsRootContainer();
            if (checkResult.isError)
                return checkResult;
        }
        if (this.rootContainer === true) {
            return this;
        }
        const parentUri = (0, rdfUtils_1.getParentUri)(this.uri);
        if (!parentUri) {
            return new NoncompliantPodError_1.NoncompliantPodError(this.uri, "Resource does not have a root container");
        }
        return this.context.resourceStore.get(parentUri).getRootContainer();
    }
    async getParentContainer() {
        const checkResult = await this.checkIfIsRootContainer();
        if (checkResult.isError)
            return checkResult;
        if (this.rootContainer)
            return undefined;
        const parentUri = (0, rdfUtils_1.getParentUri)(this.uri);
        if (!parentUri) {
            return new NoncompliantPodError_1.NoncompliantPodError(this.uri, `${this.uri} is not root does not have a parent container`);
        }
        return this.context.resourceStore.get(parentUri);
    }
    children() {
        const childQuads = this.context.solidLdoDataset.match((0, data_model_1.namedNode)(this.uri), rdfUtils_1.ldpContains, null, (0, data_model_1.namedNode)(this.uri));
        return childQuads.toArray().map((childQuad) => {
            return this.context.resourceStore.get(childQuad.object.value);
        });
    }
    child(slug) {
        return this.context.resourceStore.get(`${this.uri}${slug}`);
    }
    createChildAndOverwrite(slug) {
        return this.child(slug).createAndOverwrite();
    }
    createChildIfAbsent(slug) {
        return this.child(slug).createIfAbsent();
    }
    async uploadChildAndOverwrite(slug, blob, mimeType) {
        return this.child(slug).uploadAndOverwrite(blob, mimeType);
    }
    async uploadChildIfAbsent(slug, blob, mimeType) {
        return this.child(slug).uploadIfAbsent(blob, mimeType);
    }
    async clear() {
        const readResult = await this.read();
        if (readResult.isError)
            return new ErrorResult_1.AggregateError([readResult]);
        const results = (await Promise.all(this.children().map(async (child) => {
            return child.delete();
        }))).flat();
        const errors = results.filter((value) => value.isError);
        if (errors.length > 0) {
            return new ErrorResult_1.AggregateError(errors);
        }
        return {
            isError: false,
            type: "aggregateSuccess",
            results: results,
            resource: this,
        };
    }
    async delete() {
        const clearResult = await this.clear();
        if (clearResult.isError)
            return clearResult;
        const deleteResult = await this.handleDelete();
        if (deleteResult.isError)
            return deleteResult;
        return { ...deleteResult, resource: this };
    }
    async createAndOverwrite() {
        const createResult = (await this.handleCreateAndOverwrite());
        if (createResult.isError)
            return createResult;
        return { ...createResult, resource: this };
    }
    async createIfAbsent() {
        const createResult = (await this.handleCreateIfAbsent());
        if (createResult.isError)
            return createResult;
        return { ...createResult, resource: this };
    }
}
exports.Container = Container;
//# sourceMappingURL=Container.js.map