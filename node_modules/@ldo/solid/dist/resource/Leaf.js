"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Leaf = void 0;
const LeafRequester_1 = require("../requester/LeafRequester");
const rdfUtils_1 = require("../util/rdfUtils");
const Resource_1 = require("./Resource");
class Leaf extends Resource_1.Resource {
    constructor(uri, context) {
        super(context);
        this.type = "leaf";
        this.isError = false;
        this.uri = uri;
        this.requester = new LeafRequester_1.LeafRequester(uri, context);
        this.status = { isError: false, type: "unfetched", uri };
    }
    isUploading() {
        return this.requester.isUploading();
    }
    isUpdating() {
        return this.requester.isUpdating();
    }
    getMimeType() {
        return this.binaryData?.mimeType;
    }
    getBlob() {
        return this.binaryData?.blob;
    }
    isBinary() {
        if (!this.didInitialFetch) {
            return undefined;
        }
        return !!this.binaryData;
    }
    isDataResource() {
        if (!this.didInitialFetch) {
            return undefined;
        }
        return !this.binaryData;
    }
    updateWithReadSuccess(result) {
        super.updateWithReadSuccess(result);
        if (result.type === "binaryReadSuccess") {
            this.binaryData = { blob: result.blob, mimeType: result.mimeType };
        }
        else {
            this.binaryData = undefined;
        }
    }
    async read() {
        const result = (await this.handleRead());
        if (result.isError)
            return result;
        return { ...result, resource: this };
    }
    toReadResult() {
        if (this.isAbsent()) {
            return {
                isError: false,
                type: "absentReadSuccess",
                uri: this.uri,
                recalledFromMemory: true,
                resource: this,
            };
        }
        else if (this.isBinary()) {
            return {
                isError: false,
                type: "binaryReadSuccess",
                uri: this.uri,
                recalledFromMemory: true,
                blob: this.binaryData.blob,
                mimeType: this.binaryData.mimeType,
                resource: this,
            };
        }
        else {
            return {
                isError: false,
                type: "dataReadSuccess",
                uri: this.uri,
                recalledFromMemory: true,
                resource: this,
            };
        }
    }
    async readIfUnfetched() {
        return super.readIfUnfetched();
    }
    getParentContainer() {
        const parentUri = (0, rdfUtils_1.getParentUri)(this.uri);
        return this.context.resourceStore.get(parentUri);
    }
    getRootContainer() {
        const parentUri = (0, rdfUtils_1.getParentUri)(this.uri);
        const parent = this.context.resourceStore.get(parentUri);
        return parent.getRootContainer();
    }
    updateWithDeleteSuccess(_result) {
        this.binaryData = undefined;
    }
    updateWithCreateSuccess(_result) {
        this.binaryData = undefined;
    }
    async uploadAndOverwrite(blob, mimeType) {
        const result = await this.requester.upload(blob, mimeType, true);
        this.status = result;
        if (result.isError)
            return result;
        super.updateWithCreateSuccess(result);
        this.binaryData = { blob, mimeType };
        this.emitThisAndParent();
        return { ...result, resource: this };
    }
    async uploadIfAbsent(blob, mimeType) {
        const result = await this.requester.upload(blob, mimeType);
        this.status = result;
        if (result.isError)
            return result;
        super.updateWithCreateSuccess(result);
        this.binaryData = { blob, mimeType };
        this.emitThisAndParent();
        return { ...result, resource: this };
    }
    async update(changes) {
        const result = await this.requester.updateDataResource(changes);
        this.status = result;
        if (result.isError)
            return result;
        this.binaryData = undefined;
        this.absent = false;
        this.emitThisAndParent();
        return { ...result, resource: this };
    }
    async delete() {
        return this.handleDelete();
    }
    async createAndOverwrite() {
        const createResult = (await this.handleCreateAndOverwrite());
        if (createResult.isError)
            return createResult;
        return { ...createResult, resource: this };
    }
    async createIfAbsent() {
        const createResult = (await this.handleCreateIfAbsent());
        if (createResult.isError)
            return createResult;
        return { ...createResult, resource: this };
    }
}
exports.Leaf = Leaf;
//# sourceMappingURL=Leaf.js.map