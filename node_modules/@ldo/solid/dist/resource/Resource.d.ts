import type { SolidLdoDatasetContext } from "../SolidLdoDatasetContext";
import type { ContainerCreateAndOverwriteResult, ContainerCreateIfAbsentResult, LeafCreateAndOverwriteResult, LeafCreateIfAbsentResult } from "../requester/requests/createDataResource";
import type { ReadContainerResult, ReadLeafResult } from "../requester/requests/readResource";
import type { Requester } from "../requester/Requester";
import type { CheckRootResultError } from "../requester/requests/checkRootContainer";
import type { AccessRule } from "../requester/results/success/AccessRule";
import type { SetAccessRulesResult } from "../requester/requests/setAccessRules";
import type TypedEmitter from "typed-emitter";
import type { RequesterResult } from "../requester/results/RequesterResult";
import type { DeleteResult } from "../requester/requests/deleteResource";
import type { ReadSuccess } from "../requester/results/success/ReadSuccess";
import type { DeleteSuccess } from "../requester/results/success/DeleteSuccess";
import type { ResourceSuccess } from "../requester/results/success/SuccessResult";
import type { Unfetched } from "../requester/results/success/Unfetched";
import type { CreateSuccess } from "../requester/results/success/CreateSuccess";
import type { ResourceResult } from "./resourceResult/ResourceResult";
import type { Container } from "./Container";
import type { Leaf } from "./Leaf";
export type SharedStatuses = Unfetched | DeleteResult | CreateSuccess;
declare const Resource_base: new () => TypedEmitter<{
    update: () => void;
}>;
export declare abstract class Resource extends Resource_base {
    protected readonly context: SolidLdoDatasetContext;
    abstract readonly uri: string;
    abstract readonly type: string;
    abstract status: RequesterResult;
    protected abstract readonly requester: Requester;
    protected didInitialFetch: boolean;
    protected absent: boolean | undefined;
    constructor(context: SolidLdoDatasetContext);
    isLoading(): boolean;
    isCreating(): boolean;
    isReading(): boolean;
    isDeleting(): boolean;
    isDoingInitialFetch(): boolean;
    isReloading(): boolean;
    isFetched(): boolean;
    isUnfetched(): boolean;
    isAbsent(): boolean | undefined;
    isPresent(): boolean | undefined;
    protected emitThisAndParent(): void;
    protected updateWithReadSuccess(result: ReadSuccess): void;
    protected handleRead(): Promise<ReadContainerResult | ReadLeafResult>;
    protected abstract toReadResult(): ResourceResult<ReadLeafResult | ReadContainerResult, Container | Leaf>;
    abstract read(): Promise<ResourceResult<ReadLeafResult | ReadContainerResult, Container | Leaf>>;
    readIfUnfetched(): Promise<ResourceResult<ReadLeafResult | ReadContainerResult, Container | Leaf>>;
    protected updateWithDeleteSuccess(_result: DeleteSuccess): void;
    protected handleDelete(): Promise<DeleteResult>;
    protected updateWithCreateSuccess(result: ResourceSuccess): void;
    abstract createAndOverwrite(): Promise<ResourceResult<ContainerCreateAndOverwriteResult | LeafCreateAndOverwriteResult, Leaf | Container>>;
    protected handleCreateAndOverwrite(): Promise<ContainerCreateAndOverwriteResult | LeafCreateAndOverwriteResult>;
    abstract createIfAbsent(): Promise<ResourceResult<ContainerCreateIfAbsentResult | LeafCreateIfAbsentResult, Leaf | Container>>;
    protected handleCreateIfAbsent(): Promise<ContainerCreateIfAbsentResult | LeafCreateIfAbsentResult>;
    abstract getRootContainer(): Promise<Container | CheckRootResultError>;
    setAccessRules(newAccessRules: AccessRule): Promise<ResourceResult<SetAccessRulesResult, Leaf | Container>>;
}
export {};
