"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RequestBatcher = exports.ANY_KEY = void 0;
exports.ANY_KEY = "any";
class RequestBatcher {
    constructor(options) {
        this.lastRequestTimestampMap = {};
        this.currentlyProcessing = undefined;
        this.processQueue = [];
        this.shouldBatchAllRequests = options?.shouldBatchAllRequests || false;
        this.batchMillis = options?.batchMillis || 1000;
    }
    isLoading(key) {
        return this.currentlyProcessing?.name === key;
    }
    triggerOrWaitProcess() {
        if (!this.processQueue[0]) {
            return;
        }
        const processName = this.shouldBatchAllRequests
            ? exports.ANY_KEY
            : this.processQueue[0].name;
        if (!this.lastRequestTimestampMap[processName]) {
            this.lastRequestTimestampMap[processName] = Date.UTC(0, 0, 0, 0, 0, 0, 0);
        }
        const lastRequestTimestamp = this.lastRequestTimestampMap[processName];
        const timeSinceLastTrigger = Date.now() - lastRequestTimestamp;
        const triggerProcess = async () => {
            if (this.currentlyProcessing) {
                return;
            }
            this.lastRequestTimestampMap[processName] = Date.now();
            this.lastRequestTimestampMap[exports.ANY_KEY] = Date.now();
            const processToTrigger = this.processQueue.shift();
            if (processToTrigger) {
                this.currentlyProcessing = processToTrigger;
                try {
                    const returnValue = await processToTrigger.perform(...processToTrigger.args);
                    processToTrigger.awaitingResolutions.forEach((callback) => {
                        callback(returnValue);
                    });
                }
                catch (err) {
                    processToTrigger.awaitingRejections.forEach((callback) => {
                        callback(err);
                    });
                }
                this.currentlyProcessing = undefined;
                this.triggerOrWaitProcess();
            }
        };
        if (timeSinceLastTrigger < this.batchMillis) {
            setTimeout(triggerProcess, this.batchMillis - timeSinceLastTrigger);
        }
        else {
            triggerProcess();
        }
    }
    async queueProcess(options) {
        return new Promise((resolve, reject) => {
            const shouldAwait = options.modifyQueue(this.processQueue, this.currentlyProcessing, options.args);
            if (shouldAwait) {
                shouldAwait.awaitingResolutions.push(resolve);
                shouldAwait.awaitingRejections.push(reject);
                return;
            }
            const waitingProcess = {
                name: options.name,
                args: options.args,
                perform: options.perform,
                awaitingResolutions: [resolve],
                awaitingRejections: [reject],
            };
            this.processQueue.push(waitingProcess);
            this.triggerOrWaitProcess();
        });
    }
}
exports.RequestBatcher = RequestBatcher;
//# sourceMappingURL=RequestBatcher.js.map