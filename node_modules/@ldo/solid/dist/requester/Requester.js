"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Requester = void 0;
const RequestBatcher_1 = require("../util/RequestBatcher");
const createDataResource_1 = require("./requests/createDataResource");
const readResource_1 = require("./requests/readResource");
const deleteResource_1 = require("./requests/deleteResource");
const READ_KEY = "read";
const CREATE_KEY = "createDataResource";
const DELETE_KEY = "delete";
class Requester {
    constructor(context) {
        this.requestBatcher = new RequestBatcher_1.RequestBatcher();
        this.context = context;
    }
    isLoading() {
        return this.requestBatcher.isLoading(RequestBatcher_1.ANY_KEY);
    }
    isCreating() {
        return this.requestBatcher.isLoading(CREATE_KEY);
    }
    isReading() {
        return this.requestBatcher.isLoading(READ_KEY);
    }
    isDeletinng() {
        return this.requestBatcher.isLoading(DELETE_KEY);
    }
    async read() {
        const transaction = this.context.solidLdoDataset.startTransaction();
        const result = await this.requestBatcher.queueProcess({
            name: READ_KEY,
            args: [this.uri, { dataset: transaction, fetch: this.context.fetch }],
            perform: readResource_1.readResource,
            modifyQueue: (queue, currentlyLoading) => {
                if (queue.length === 0 && currentlyLoading?.name === READ_KEY) {
                    return currentlyLoading;
                }
                else if (queue[queue.length - 1]?.name === READ_KEY) {
                    return queue[queue.length - 1];
                }
                return undefined;
            },
        });
        if (!result.isError) {
            transaction.commit();
        }
        return result;
    }
    async delete() {
        const transaction = this.context.solidLdoDataset.startTransaction();
        const result = await this.requestBatcher.queueProcess({
            name: DELETE_KEY,
            args: [this.uri, { dataset: transaction, fetch: this.context.fetch }],
            perform: deleteResource_1.deleteResource,
            modifyQueue: (queue, currentlyLoading) => {
                if (queue.length === 0 && currentlyLoading?.name === DELETE_KEY) {
                    return currentlyLoading;
                }
                else if (queue[queue.length - 1]?.name === DELETE_KEY) {
                    return queue[queue.length - 1];
                }
                return undefined;
            },
        });
        if (!result.isError) {
            transaction.commit();
        }
        return result;
    }
    async createDataResource(overwrite) {
        const transaction = this.context.solidLdoDataset.startTransaction();
        const result = await this.requestBatcher.queueProcess({
            name: CREATE_KEY,
            args: [
                this.uri,
                overwrite,
                { dataset: transaction, fetch: this.context.fetch },
            ],
            perform: createDataResource_1.createDataResource,
            modifyQueue: (queue, currentlyLoading, args) => {
                const lastElementInQueue = queue[queue.length - 1];
                if (lastElementInQueue &&
                    lastElementInQueue.name === CREATE_KEY &&
                    !!lastElementInQueue.args[1] === !!args[1]) {
                    return lastElementInQueue;
                }
                if (currentlyLoading &&
                    currentlyLoading.name === CREATE_KEY &&
                    !!currentlyLoading.args[1] === !!args[1]) {
                    return currentlyLoading;
                }
                return undefined;
            },
        });
        if (!result.isError) {
            transaction.commit();
        }
        return result;
    }
}
exports.Requester = Requester;
//# sourceMappingURL=Requester.js.map