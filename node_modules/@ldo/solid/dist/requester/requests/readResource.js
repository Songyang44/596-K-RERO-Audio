"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readResource = void 0;
const HttpErrorResult_1 = require("../results/error/HttpErrorResult");
const rdfUtils_1 = require("../../util/rdfUtils");
const uriTypes_1 = require("../../util/uriTypes");
const NoncompliantPodError_1 = require("../results/error/NoncompliantPodError");
const guaranteeFetch_1 = require("../../util/guaranteeFetch");
const ErrorResult_1 = require("../results/error/ErrorResult");
const checkRootContainer_1 = require("./checkRootContainer");
async function readResource(uri, options) {
    try {
        const fetch = (0, guaranteeFetch_1.guaranteeFetch)(options?.fetch);
        const response = await fetch(uri);
        if (response.status === 404) {
            return {
                isError: false,
                type: "absentReadSuccess",
                uri,
                recalledFromMemory: false,
            };
        }
        const httpErrorResult = HttpErrorResult_1.HttpErrorResult.checkResponse(uri, response);
        if (httpErrorResult)
            return httpErrorResult;
        if (options?.dataset) {
            (0, rdfUtils_1.addResourceRdfToContainer)(uri, options.dataset);
        }
        const contentType = response.headers.get("content-type");
        if (!contentType) {
            return new NoncompliantPodError_1.NoncompliantPodError(uri, "Resource requests must return a content-type header.");
        }
        if (contentType === "text/turtle") {
            const rawTurtle = await response.text();
            if (options?.dataset) {
                const result = await (0, rdfUtils_1.addRawTurtleToDataset)(rawTurtle, options.dataset, uri);
                if (result)
                    return result;
            }
            if ((0, uriTypes_1.isContainerUri)(uri)) {
                const result = (0, checkRootContainer_1.checkHeadersForRootContainer)(uri, response.headers);
                if (result.isError)
                    return result;
                return {
                    isError: false,
                    type: "containerReadSuccess",
                    uri,
                    recalledFromMemory: false,
                    isRootContainer: result.isRootContainer,
                };
            }
            return {
                isError: false,
                type: "dataReadSuccess",
                uri,
                recalledFromMemory: false,
            };
        }
        else {
            const blob = await response.blob();
            return {
                isError: false,
                type: "binaryReadSuccess",
                uri,
                recalledFromMemory: false,
                blob,
                mimeType: contentType,
            };
        }
    }
    catch (err) {
        return ErrorResult_1.UnexpectedResourceError.fromThrown(uri, err);
    }
}
exports.readResource = readResource;
//# sourceMappingURL=readResource.js.map