"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadResource = void 0;
const guaranteeFetch_1 = require("../../util/guaranteeFetch");
const rdfUtils_1 = require("../../util/rdfUtils");
const ErrorResult_1 = require("../results/error/ErrorResult");
const HttpErrorResult_1 = require("../results/error/HttpErrorResult");
const deleteResource_1 = require("./deleteResource");
const readResource_1 = require("./readResource");
async function uploadResource(uri, blob, mimeType, overwrite, options) {
    try {
        const fetch = (0, guaranteeFetch_1.guaranteeFetch)(options?.fetch);
        if (overwrite) {
            const deleteResult = await (0, deleteResource_1.deleteResource)(uri, options);
            if (deleteResult.isError)
                return deleteResult;
        }
        else {
            const readResult = await (0, readResource_1.readResource)(uri, options);
            if (readResult.type !== "absentReadSuccess") {
                return readResult;
            }
        }
        const parentUri = (0, rdfUtils_1.getParentUri)(uri);
        const response = await fetch(parentUri, {
            method: "post",
            headers: {
                "content-type": mimeType,
                slug: (0, rdfUtils_1.getSlug)(uri),
            },
            body: blob,
        });
        const httpError = HttpErrorResult_1.HttpErrorResult.checkResponse(uri, response);
        if (httpError)
            return httpError;
        if (options?.dataset) {
            (0, rdfUtils_1.addResourceRdfToContainer)(uri, options.dataset);
        }
        return {
            isError: false,
            type: "createSuccess",
            uri,
            didOverwrite: !!overwrite,
        };
    }
    catch (err) {
        return ErrorResult_1.UnexpectedResourceError.fromThrown(uri, err);
    }
}
exports.uploadResource = uploadResource;
//# sourceMappingURL=uploadResource.js.map