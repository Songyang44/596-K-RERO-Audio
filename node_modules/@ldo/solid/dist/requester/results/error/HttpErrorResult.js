"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ServerHttpError = exports.UnauthenticatedHttpError = exports.UnexpectedHttpError = exports.HttpErrorResult = void 0;
const ErrorResult_1 = require("./ErrorResult");
class HttpErrorResult extends ErrorResult_1.ResourceError {
    constructor(uri, response, message) {
        super(uri, message ||
            `Request for ${uri} returned ${response.status} (${response.statusText}).`);
        this.status = response.status;
        this.headers = response.headers;
        this.response = response;
    }
    async getBodyForDebug() {
        if (this.response.bodyUsed) {
            return `Could not get body for ${this.uri} that yeilded status ${this.status}. The body stream has already been consumed.`;
        }
        return await this.response.text();
    }
    static isnt(response) {
        return (!(response.status >= 200 || response.status < 300) &&
            response.status !== 404 &&
            response.status !== 304);
    }
    static checkResponse(uri, response) {
        if (ServerHttpError.is(response)) {
            return new ServerHttpError(uri, response);
        }
        if (UnauthenticatedHttpError.is(response)) {
            return new UnauthenticatedHttpError(uri, response);
        }
        if (HttpErrorResult.isnt(response)) {
            return new UnexpectedHttpError(uri, response);
        }
        return undefined;
    }
}
exports.HttpErrorResult = HttpErrorResult;
class UnexpectedHttpError extends HttpErrorResult {
    constructor() {
        super(...arguments);
        this.type = "unexpectedHttpError";
    }
}
exports.UnexpectedHttpError = UnexpectedHttpError;
class UnauthenticatedHttpError extends HttpErrorResult {
    constructor() {
        super(...arguments);
        this.type = "unauthenticatedError";
    }
    static is(response) {
        return response.status === 401;
    }
}
exports.UnauthenticatedHttpError = UnauthenticatedHttpError;
class ServerHttpError extends HttpErrorResult {
    constructor() {
        super(...arguments);
        this.type = "serverError";
    }
    static is(response) {
        return response.status >= 500 && response.status < 600;
    }
}
exports.ServerHttpError = ServerHttpError;
//# sourceMappingURL=HttpErrorResult.js.map