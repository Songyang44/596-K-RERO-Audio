"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LeafRequester = exports.UPLOAD_KEY = exports.UPDATE_KEY = void 0;
const subscribable_dataset_1 = require("@ldo/subscribable-dataset");
const Requester_1 = require("./Requester");
const updateDataResource_1 = require("./requests/updateDataResource");
const uploadResource_1 = require("./requests/uploadResource");
exports.UPDATE_KEY = "update";
exports.UPLOAD_KEY = "upload";
class LeafRequester extends Requester_1.Requester {
    constructor(uri, context) {
        super(context);
        this.uri = uri;
    }
    isUpdating() {
        return this.requestBatcher.isLoading(exports.UPDATE_KEY);
    }
    isUploading() {
        return this.requestBatcher.isLoading(exports.UPLOAD_KEY);
    }
    async read() {
        return super.read();
    }
    createDataResource(overwrite) {
        return super.createDataResource(overwrite);
    }
    async updateDataResource(changes) {
        const transaction = this.context.solidLdoDataset.startTransaction();
        transaction.addAll(changes.added || []);
        changes.removed?.forEach((quad) => transaction.delete(quad));
        transaction.commit();
        const result = await this.requestBatcher.queueProcess({
            name: exports.UPDATE_KEY,
            args: [
                this.uri,
                changes,
                { fetch: this.context.fetch, onRollback: () => transaction.rollback() },
            ],
            perform: updateDataResource_1.updateDataResource,
            modifyQueue: (queue, currentlyProcessing, [, changes]) => {
                if (queue[queue.length - 1]?.name === exports.UPDATE_KEY) {
                    const originalChanges = queue[queue.length - 1].args[1];
                    (0, subscribable_dataset_1.mergeDatasetChanges)(originalChanges, changes);
                    return queue[queue.length - 1];
                }
                return undefined;
            },
        });
        return result;
    }
    async upload(blob, mimeType, overwrite) {
        const transaction = this.context.solidLdoDataset.startTransaction();
        const result = await this.requestBatcher.queueProcess({
            name: exports.UPLOAD_KEY,
            args: [
                this.uri,
                blob,
                mimeType,
                overwrite,
                { dataset: transaction, fetch: this.context.fetch },
            ],
            perform: uploadResource_1.uploadResource,
            modifyQueue: (queue, currentlyLoading, args) => {
                const lastElementInQueue = queue[queue.length - 1];
                if (lastElementInQueue &&
                    lastElementInQueue.name === exports.UPLOAD_KEY &&
                    !!lastElementInQueue.args[3] === !!args[3]) {
                    return lastElementInQueue;
                }
                if (currentlyLoading &&
                    currentlyLoading.name === exports.UPLOAD_KEY &&
                    !!currentlyLoading.args[3] === !!args[3]) {
                    return currentlyLoading;
                }
                return undefined;
            },
        });
        if (!result.isError) {
            transaction.commit();
        }
        return result;
    }
}
exports.LeafRequester = LeafRequester;
//# sourceMappingURL=LeafRequester.js.map