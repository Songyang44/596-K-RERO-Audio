"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const data_model_1 = require("@rdfjs/data-model");
const ProxyTransactionalDataset_1 = __importDefault(require("./ProxyTransactionalDataset"));
class WrapperSubscribableDataset {
    constructor(datasetFactory, initialDataset) {
        this.NAMED_NODE_KEY_PREFIX = "NamedNode";
        this.BLANK_NODE_KEY_PREFIX = "BlankNode";
        this.DEFAULT_GRAPH_KEY_PREFIX = "DefaultGraph";
        this.SUBSCRIBABLE_TERMS = [
            this.NAMED_NODE_KEY_PREFIX,
            this.BLANK_NODE_KEY_PREFIX,
            this.DEFAULT_GRAPH_KEY_PREFIX,
        ];
        this.datasetFactory = datasetFactory;
        this.dataset = initialDataset || this.datasetFactory.dataset();
        this.eventEmitter = new events_1.EventEmitter();
    }
    addAll(quads) {
        this.dataset.addAll(quads);
        this.triggerSubscriptionForQuads({
            added: this.datasetFactory.dataset(quads),
        });
        return this;
    }
    bulk(changed) {
        if (changed.added) {
            this.dataset.addAll(changed.added);
        }
        if (changed.removed) {
            changed.removed.forEach((quad) => {
                this.dataset.delete(quad);
            });
        }
        this.triggerSubscriptionForQuads(changed);
        return this;
    }
    contains(other) {
        return this.dataset.contains(other);
    }
    deleteMatches(subject, predicate, object, graph) {
        const matching = this.dataset.match(subject, predicate, object, graph);
        for (const quad of matching) {
            this.dataset.delete(quad);
        }
        this.triggerSubscriptionForQuads({ removed: matching });
        return this;
    }
    difference(other) {
        return this.dataset.difference(other);
    }
    equals(other) {
        return this.dataset.equals(other);
    }
    every(iteratee) {
        return this.dataset.every((quad) => iteratee(quad, this));
    }
    filter(iteratee) {
        return this.dataset.filter((quad) => iteratee(quad, this));
    }
    forEach(iteratee) {
        return this.dataset.forEach((quad) => iteratee(quad, this));
    }
    async import(stream) {
        await this.dataset.import(stream);
        return this;
    }
    intersection(other) {
        return this.dataset.intersection(other);
    }
    map(iteratee) {
        return this.dataset.map((quad) => iteratee(quad, this));
    }
    reduce(iteratee, initialValue) {
        return this.dataset.reduce((acc, quad) => iteratee(acc, quad, this), initialValue);
    }
    some(iteratee) {
        return this.dataset.some((quad) => iteratee(quad, this));
    }
    toArray() {
        return this.dataset.toArray();
    }
    toCanonical() {
        return this.dataset.toCanonical();
    }
    toStream() {
        return this.dataset.toStream();
    }
    toString() {
        return this.dataset.toString();
    }
    union(quads) {
        return this.dataset.union(quads);
    }
    match(subject, predicate, object, graph) {
        return this.dataset.match(subject, predicate, object, graph);
    }
    get size() {
        return this.dataset.size;
    }
    add(quad) {
        this.dataset.add(quad);
        this.triggerSubscriptionForQuads({
            added: this.datasetFactory.dataset([quad]),
        });
        return this;
    }
    delete(quad) {
        this.dataset.delete(quad);
        this.triggerSubscriptionForQuads({
            removed: this.datasetFactory.dataset([quad]),
        });
        return this;
    }
    has(quad) {
        return this.dataset.has(quad);
    }
    [Symbol.iterator]() {
        return this.dataset[Symbol.iterator]();
    }
    getKeyFromNode(term) {
        if (term.termType === "NamedNode") {
            return `${this.NAMED_NODE_KEY_PREFIX}${term.value}`;
        }
        else if (term.termType === "BlankNode") {
            return `${this.BLANK_NODE_KEY_PREFIX}${term.value}`;
        }
        else if (term.termType === "DefaultGraph") {
            return `${this.DEFAULT_GRAPH_KEY_PREFIX}${term.value}`;
        }
        throw new Error("Invalid term type for subscription");
    }
    getNodeFromKey(key) {
        if (key.startsWith(this.NAMED_NODE_KEY_PREFIX)) {
            return (0, data_model_1.namedNode)(key.slice(this.NAMED_NODE_KEY_PREFIX.length));
        }
        else if (key.startsWith(this.BLANK_NODE_KEY_PREFIX)) {
            return (0, data_model_1.blankNode)(key.slice(this.BLANK_NODE_KEY_PREFIX.length));
        }
        else if (key.startsWith(this.DEFAULT_GRAPH_KEY_PREFIX)) {
            return (0, data_model_1.defaultGraph)();
        }
        throw Error("Invalid Subscription Key");
    }
    triggerSubscriptionForQuads(changed) {
        const triggeredTermsMap = {};
        const forEachQuad = (quad) => {
            const subject = quad.subject;
            const predicate = quad.predicate;
            const object = quad.object;
            const graph = quad.graph;
            const quadTerms = [subject, predicate, object, graph];
            quadTerms.forEach((quadTerm) => {
                if (this.SUBSCRIBABLE_TERMS.includes(quadTerm.termType)) {
                    triggeredTermsMap[`${quadTerm.termType}${quadTerm.value}`] =
                        quadTerm;
                }
            });
        };
        changed.added?.forEach(forEachQuad);
        changed.removed?.forEach(forEachQuad);
        const triggeredTerms = Object.values(triggeredTermsMap);
        triggeredTerms.forEach((triggeredTerm) => {
            this.triggerSubscriptionForNode(triggeredTerm, changed);
        });
    }
    triggerSubscriptionForNode(term, changed) {
        if (this.listenerCount(term) > 0) {
            let allQuads = this.datasetFactory.dataset();
            if (term.termType !== "DefaultGraph") {
                allQuads = allQuads.union(this.match(term, null, null, null));
                allQuads = allQuads.union(this.match(null, null, term, null));
                if (term.termType !== "BlankNode") {
                    allQuads = allQuads.union(this.match(null, term, null, null));
                    allQuads = allQuads.union(this.match(null, null, null, term));
                }
            }
            else {
                allQuads = allQuads.union(this.match(null, null, null, term));
            }
            let changedForThisNode = {
                added: changed.added
                    ? changed.added.filter((addedQuad) => addedQuad.subject.equals(term) ||
                        addedQuad.predicate.equals(term) ||
                        addedQuad.object.equals(term) ||
                        addedQuad.graph.equals(term))
                    : undefined,
                removed: changed.removed
                    ? changed.removed.filter((removedQuad) => removedQuad.subject.equals(term) ||
                        removedQuad.predicate.equals(term) ||
                        removedQuad.object.equals(term) ||
                        removedQuad.graph.equals(term))
                    : undefined,
            };
            changedForThisNode = {
                added: changedForThisNode.added && changedForThisNode.added.size > 0
                    ? changedForThisNode.added
                    : undefined,
                removed: changedForThisNode.removed && changedForThisNode.removed.size > 0
                    ? changedForThisNode.removed
                    : undefined,
            };
            this.emit(term, allQuads, changedForThisNode);
        }
    }
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    emit(eventName, dataset, datasetChanges) {
        return this.eventEmitter.emit(this.getKeyFromNode(eventName), dataset, datasetChanges);
    }
    eventNames() {
        return this.eventEmitter
            .eventNames()
            .map((eventName) => this.getNodeFromKey(eventName));
    }
    getMaxListeners() {
        return this.eventEmitter.getMaxListeners();
    }
    listenerCount(eventName) {
        return this.eventEmitter.listenerCount(this.getKeyFromNode(eventName));
    }
    listeners(eventName) {
        return this.eventEmitter.listeners(this.getKeyFromNode(eventName));
    }
    off(eventName, listener) {
        this.removeListener(eventName, listener);
    }
    on(eventName, listener) {
        this.eventEmitter.on(this.getKeyFromNode(eventName), listener);
        return this;
    }
    once(eventName, listener) {
        this.eventEmitter.once(this.getKeyFromNode(eventName), listener);
        return this;
    }
    prependListener(eventName, listener) {
        this.eventEmitter.prependListener(this.getKeyFromNode(eventName), listener);
        return this;
    }
    prependOnceListener(eventName, listener) {
        this.eventEmitter.prependOnceListener(this.getKeyFromNode(eventName), listener);
        return this;
    }
    removeAllListeners(eventName) {
        this.eventEmitter.removeAllListeners(this.getKeyFromNode(eventName));
        return this;
    }
    removeListener(eventName, listener) {
        this.eventEmitter.removeListener(this.getKeyFromNode(eventName), listener);
        return this;
    }
    setMaxListeners(n) {
        this.eventEmitter.setMaxListeners(n);
        return this;
    }
    rawListeners(eventName) {
        return this.eventEmitter.rawListeners(this.getKeyFromNode(eventName));
    }
    startTransaction() {
        return new ProxyTransactionalDataset_1.default(this, this.datasetFactory);
    }
}
exports.default = WrapperSubscribableDataset;
//# sourceMappingURL=WrapperSubscribableDataset.js.map