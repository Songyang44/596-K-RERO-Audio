"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const dataset_1 = require("@ldo/dataset");
const mergeDatasetChanges_1 = require("./mergeDatasetChanges");
class ProxyTransactionalDataset extends dataset_1.ExtendedDataset {
    constructor(parentDataset, datasetFactory) {
        super(datasetFactory.dataset(), datasetFactory);
        this.parentDataset = parentDataset;
        this.datasetFactory = datasetFactory;
        this.datasetChanges = {};
    }
    addAll(quads) {
        this.updateDatasetChanges({ added: quads });
        return this;
    }
    bulk(changes) {
        this.updateDatasetChanges(changes);
        return this;
    }
    deleteMatches(subject, predicate, object, graph) {
        this.checkIfTransactionCommitted();
        const matching = this.match(subject, predicate, object, graph);
        for (const quad of matching) {
            this.delete(quad);
        }
        return this;
    }
    match(subject, predicate, object, graph) {
        let finalMatch = this.parentDataset.match(subject, predicate, object, graph);
        if (this.datasetChanges.removed) {
            finalMatch = finalMatch.difference(this.datasetChanges.removed);
        }
        if (this.datasetChanges.added) {
            finalMatch = finalMatch.union(this.datasetChanges.added.match(subject, predicate, object, graph));
        }
        return finalMatch;
    }
    get size() {
        return (this.parentDataset.size +
            (this.datasetChanges.added?.difference(this.parentDataset).size || 0) -
            (this.datasetChanges.removed?.intersection(this.parentDataset).size || 0));
    }
    add(quad) {
        this.updateDatasetChanges({ added: [quad] });
        return this;
    }
    delete(quad) {
        this.updateDatasetChanges({ removed: [quad] });
        return this;
    }
    has(quad) {
        return (!this.datasetChanges.removed?.has(quad) &&
            (this.datasetChanges.added?.has(quad) || this.parentDataset.has(quad)));
    }
    [Symbol.iterator]() {
        const addedIterator = (this.datasetChanges.added || [])[Symbol.iterator]();
        let addedNext = addedIterator.next();
        const parentIterator = this.parentDataset[Symbol.iterator]();
        let parentNext = parentIterator.next();
        return {
            next: () => {
                if (!addedNext || !addedNext.done) {
                    const toReturn = addedNext;
                    addedNext = addedIterator.next();
                    return toReturn;
                }
                while (!parentNext.done) {
                    const toReturn = parentNext;
                    parentNext = parentIterator.next();
                    if (!(this.datasetChanges.added &&
                        this.datasetChanges.added.has(toReturn.value)) &&
                        !(this.datasetChanges.removed &&
                            this.datasetChanges.removed.has(toReturn.value))) {
                        return toReturn;
                    }
                }
                return { value: undefined, done: true };
            },
        };
    }
    checkIfTransactionCommitted() {
        if (this.committedDatasetChanges) {
            throw new Error("Transaction has already committed");
        }
    }
    updateDatasetChanges(changes) {
        this.checkIfTransactionCommitted();
        (0, mergeDatasetChanges_1.mergeDatasetChanges)(this.datasetChanges, {
            added: changes.added
                ? this.datasetFactory.dataset(changes.added)
                : undefined,
            removed: changes.removed
                ? this.datasetFactory.dataset(changes.removed)
                : undefined,
        });
    }
    updateParentDataset(datasetChanges) {
        if (this.parentDataset.bulk) {
            this.parentDataset.bulk(datasetChanges);
        }
        else {
            if (datasetChanges.added) {
                this.parentDataset.addAll(datasetChanges.added);
            }
            if (datasetChanges.removed) {
                datasetChanges.removed.forEach((curQuad) => {
                    this.parentDataset.delete(curQuad);
                });
            }
        }
    }
    commit() {
        this.checkIfTransactionCommitted();
        this.committedDatasetChanges = {
            added: this.datasetChanges.added?.difference(this.parentDataset),
            removed: this.datasetChanges.removed?.intersection(this.parentDataset),
        };
        this.updateParentDataset(this.committedDatasetChanges);
    }
    rollback() {
        if (!this.committedDatasetChanges) {
            throw new Error("Cannot rollback. Transaction has not yet been committed");
        }
        this.updateParentDataset({
            added: this.committedDatasetChanges.removed,
            removed: this.committedDatasetChanges.added,
        });
        this.committedDatasetChanges = undefined;
    }
    startTransaction() {
        return new ProxyTransactionalDataset(this, this.datasetFactory);
    }
    getChanges() {
        return this.datasetChanges;
    }
}
exports.default = ProxyTransactionalDataset;
//# sourceMappingURL=ProxyTransactionalDataset.js.map